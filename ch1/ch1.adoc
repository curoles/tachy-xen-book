== Zen of Xen

=== Power of Name

If you are a fan of fantasy books, you know that a name has power.
Let us find out what name Xen means.
Xen was originally developed as virtual machine monitor for XenoServers project.
Word _xeno_ (/'zeno) originates from Greek word xenos,
meaning "alien, stranger, foreigner".
Therefore the name Xen is hinting at advanced alien technology.

Word Xen is often combined with word "hypervisor",
because Xen virtual machine monitor is a hypervisor.
Prefix _hyper_ here means "super-duper". 
OS kernel runs at elevated privilege level compare to applications
and is called _supervisor_ because it a) manages the applications
and b) has more priviledges than application code.
When OS kernel runs under control of Xen virtual machine monitor,
the kernal is supervised by the Xen, and Xen has higher privilege level.
The fact that Xen runs at higher privilege level than "supervisor mode" OS code
and supervises it is the origin of the term "hypervisor".

Sometimes word Xen is used just for the hypervisor,
other times it is used for all the parts involved in to
the virtualization solution:
hypervisor, OS kernel virtualization modifications,
drivers for paravirtualization, tools and etc.

=== What Is Virtualization?

Xen virtualizes the computing system as whole,
including CPU, memory, storage devices, network resources, I/O devices and etc.
The virtualization in this case is the act of creating a virtual
(rather than actual) version of a computer hardware platform.
Normally, in order to get most benifits from the virtualization,
more than one virtual hardware platform is created.
The case when a single virtual platform is created
can be considered an emulation (and it is also has its usages).

=== Hypervisor-based approach to virtualization

There are many different approaches to virtualization,
we are not going to discuss and compare them here;
if you are interested in this topic,
there are many available books and Internet resources that explain
different virtualization techniques.
Xen is using hypervisor-based approach, where a hypervisor
is a low-level virtual machine monitor that runs directly
on the physical hardware and loads first during the machine
boot process.
The hypervisor runs virtual machines (VM).
Virtual machine runs operating system (which runs applications).
Normally, an operating system is compiled for the same instruction set
as the physical machine on which the virtual systems are running.

[ditaa]
....
+------------------------------------------------+
|                                                |
| +--------------------------------------------+ |
| |                                            | |
| | +----------+  +----------+  +----------+   | |
| | | Virtual  |  | Virtual  |  | Virtual  |   | |
| | | Machine  |  | Machine  |  | Machine  |   | |
| | |  with    |  |  with    |  |  with    |   | |
| | | Admini-  |  | Guest OS |  | Guest OS |   | |
| | | strative |  |          |  |          |   | |
| | | Control  |  +----------+  +----------+   | |
| | |          |     domU          domU        | |
| | |          |                               | |
| | +----------+                               | |
| |    dom0                                    | |
| |                 Hypervisor                 | |
| | cPNK                                       | |
| +--------------------------------------------+ |
|                                                |
|                    Hardware                    |
| cBLU                                           |
+------------------------------------------------+
....

Xen terminology defines a concept of "Xen domain", which is
a specific instance of a Xen virtual machine.
Xen supports two basic types of domains:

* Xen architecture has one domain with a specially privileged
  Xen-modified kernel that is used to manage, monitor, and administer all
  other Xen virtual machines. This specially priviliged domain and
  kernel is known as _domain0_ or _dom0_.
  This kernel communicates with the hypervisor.
* Other domains are known as guest domains, unprivileged domains,
  _domainU_ or _domU_.
  It is _dom0_ that starts any _domU_.

=== CPU Virtualization

For a CPU to be completely virtualized, core running in one domain must not
affect code running in another domains.
Privileged instructions have direct access to CPU resources and can access
memory by physical address. These instructions present the biggest
problem for virtualization, as they can change CPU state and affect
all code running on that CPU.
Popek and Goldberg <<popek>> in their 1974 paper
"Formal Requirements for Virtualizable Third Generation Archotectures."
devide critical for virtualization instructions into three categories:

* Privileged instructions that execute in a privilege mode.
  They have to trap if executed outside of their privilege mode.
  In a virtualized system, the trap handler makes sure that
  the effect of the instruction is contained inside the domain.
* Control sensitive instructions that change global CPU state
  by communicating with devices, changing global configuration registers,
  updating virtual to physical memory mappings.
* Behavior sensitive instructions that behave differently depending
  on the configuration.

In order for an architecture to be virtualizable, all control sensitive
instructions must be trappable privileged instructions.

=== Memory Virtualization

Memory virtualization is relatively straightforward.
Each physical memory page is assigned to one domain,
this way physical memory is spit between domains;
the difficulty is
due to the fact that OS kernel virtual-to-physical translation
operates with interemidiate "psedo" physical address that needs to be
translated into "real" physical address, called machine address.
Every priviliged instruction that accesses physical memory or
changes virtual to physical mapping must be trapped.

.Memory virtualization performance critical HW support
* HW support for 2 levels page-tables walk: virtual-to-physical
  and physical-to-machine.
* Tagged TLB that allows flushing per domain, without flushing all TLB entries.

=== I/O Virtualization

With devices, other than CPU and memory, there are two main reasons
why virtualization is difficult:

* Most devices are not designed with virtualization in mind.
* For some devices it is not obvious what virtualization means for them
  or how these devices can support virtualization.

For example, most of the time it is easier to assign keyboard, mouse
and display to one domain, instead of sharing it.
On other hand, storage devices and network devices most of the time
are shared.

Storage devices are usually virtualized similar to memory by partitioning
the physical space between domains.

One well known problem is when a device uses DMA without
support from _Input/Output Memory Management Unit_ (IOMMU).
When unmodified OS is unaware it is running not on actual hardware
platform but on virtual platform, DMA will use hypervisor-provided
physical address instead of machine address.

Here is a list of suggestions for choosing existing devices for your system
or when new device is to be designed:

* Make sure the device has _Input/Output Memory Management Unit_ (IOMMU).
* Make sure the whole device state can be saved and later restored.
* For security critical devices, make sure there is a way to protect
  information in case multiple domains share this device.

=== Paravirtualization

TODO

=== Hardware-Assisted Virtualization

TODO

=== Types of virtualization

TODO check Xen wiki, 5 types total?

=== History Of Problems with Virtualization

While designing a new CPU the architects should be aware of the problems other CPU architectures
had or still have to support virtualization by Xen.
The understading of past and existing problems is crutial in designing
a CPU that can support virtualization efficiently, when overhead of running
the hypervisor is practically unnoticeable.

* One well known problem with x86 was that some privileged instructions did not
  trap when they were executed with unsufficient privileges failing silently.
  Some virtualizers monitored instruction stream and patched those misbehaving
  instructions, practically performing binary translation, which caused
  significant degradation of performance.
* In past many architechtures did not have a protection level designed specifically
  for a hypervisor even when they have several protection levels.
* In case of paravirtualization, an absense of a special instructions in the ISA
  to be used for fast hypecall to the hypervisor is very critical for the performance.
* It used to be on x86 that booting 32-bit domain0 dictated all other domainU kernels
  to be 32-bit, similar for 64-bit domain0.
  New CPU architecture should allow different meaningful combinations of kernels, including
  bitness and endianess.
* TODO DMA, absence of IOMMU
* TODO Need to use QEMU for full system virtualization FVM

=== CPU And System Support For Virtualization

.Required functinality
* Ability to bind a virtual machine to a specific CPU on the host system.
  It helps to solve performance problems of a virtual machine under heavy load.
* No limitation for the size of virtual address space available for OS kernels
  running inside virtual machine.
* Each guest OS may create high network traffic, multiple guests can easily
  overload the capabilities of a single network interface.
  The system must support multiple network interfaces with high bandwidth.
* The system must support high IO traffic as guests may run storage intensive
  applications, such as database applications.
* The system must satisfy all requirements of Trusted Computing for the virtualized
  environment when multiple operating systems are simultaneously running on
  a single platform (with a single TPM device).
  Including the secure migration of the TPM state from one physical system
  to another when domainU guests are migrated from one system to another.
* Security concerns due to potential information leaks when
  instructions executed speculatively.
* Ability to save virtual machine state and migrate it easily to another machine.
* Ability to debug code in any privilige mode (protection ring).